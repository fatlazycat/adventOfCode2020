/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package adventOfCode2020

import kotlin.test.Test

class AppTest {
    @Test fun testDayOne() {
        println("size now is " + TestData.day1.size)
        val lessThan2020 = TestData.day1.filter { it < 2020 }
        println("size now is " + lessThan2020.size)
        val matches = matchesd1p1(lessThan2020)
        print("Result = " + matches + matches.map { p -> p.first * p.second })
        assert(matches == listOf(Pair(321, 1699), Pair(1699, 321)))
    }

    @Test fun testDayOnePartTwo() {
        println("size now is " + TestData.day1.size)
        val lessThan2020 = TestData.day1.filter { it < 2020 }
        println("size now is " + lessThan2020.size)
        val result = triples(lessThan2020)
        result?.let { t -> println("answer is " + (t.first * t.second * t.third)) }
    }

    private fun matchesd1p1(values: List<Int>) : List<Pair<Int,Int>> {
        return values.map { v -> sumTo2020(v, values.filter { it != v }) }.flatten()
    }

    private fun sumTo2020(left: Int, right: List<Int>): List<Pair<Int,Int>> {
        return right.map{ Pair(left, it) }.filter{ p -> p.first + p.second == 2020 }
    }

    private fun triples(l: List<Int>) : Triple<Int, Int, Int>? {
        for (first in l) {
            for(second in l) {
                for(third in l) {
                    if(first != second && second != third && first != third && (first + second + third) == 2020) {
                        return Triple(first, second, third)
                    }
                }
            }
        }

        return null
    }

    @Test fun testDayTwo() {
        val passing = TestData.day2.filter { s -> passwordMatch(s.split(" ")) }
        println("count is " + passing.size)
    }

    @Test fun testDayTwoPartTwo() {
        val passing = TestData.day2.filter { s -> passwordMatchPartTwo(s.split(" ")) }
        println("count is " + passing.size)
    }

    private fun passwordMatch(values: List<String>) : Boolean {
        val low = values[0].split("-")[0].toInt()
        val high = values[0].split("-")[1].toInt()
        val letter = values[1].split(":")[0][0]
        val password = values[2]
        val occurrences = password.count { it == letter }

        return occurrences in low..high
    }

    private fun passwordMatchPartTwo(values: List<String>) : Boolean {
        val low = values[0].split("-")[0].toInt() - 1
        val high = values[0].split("-")[1].toInt() - 1
        val letter = values[1].split(":")[0][0]
        val password = values[2]

        return (password[low] == letter && password[high] != letter) || (password[low] != letter && password[high] == letter)
    }

    @Test fun testDay3() {
        val data: Map<Pair<Int, Int>, Char> = TestData.day3.mapIndexed{ rowIndex, row -> row.mapIndexed{ colIndex, cell -> Pair(Pair(colIndex, rowIndex), cell)}}.flatten().toMap()
        val beyondRow = TestData.day3.size

        assert(numTrees(3,1, data, beyondRow) == 268)

        val woods: Map<Pair<Int, Int>, Char> = TestData.day3.mapIndexed{ rowIndex, row -> row.mapIndexed{ colIndex, cell -> Pair(Pair(colIndex, rowIndex), cell)}}.flatten().toMap()
        val col = 3
        val row = 1
        val path = (row..beyondRow step row).map { i -> Pair((col * i).rem(31), i) }
        val trees = path.fold(0){total, step -> if (woods[step] == '#') total+1 else total}
        assert(trees == 268)
    }

    @Test fun testDay3PartTwo() {
        val data: Map<Pair<Int, Int>, Char> = TestData.day3.mapIndexed{ rowIndex, row -> row.mapIndexed{ colIndex, cell -> Pair(Pair(colIndex, rowIndex), cell)}}.flatten().toMap()
        val beyondRow = TestData.day3.size
        val v1 = numTrees(1,1, data, beyondRow).toLong()
        val v2 = numTrees(3,1, data, beyondRow).toLong()
        val v3 = numTrees(5,1, data, beyondRow).toLong()
        val v4 = numTrees(7,1, data, beyondRow).toLong()
        val v5 = numTrees(1,2, data, beyondRow).toLong()

        assert(v1 * v2 * v3 * v4 * v5 == 3093068400)
    }

    private fun numTrees(col: Int, row: Int, data: Map<Pair<Int, Int>, Char>, size: Int) : Int {
        val path = (row..size step row).map { i -> Pair((col * (i/row)).rem(31), i) }
        return path.map { p -> isTree(p.first, p.second, data) }.sum()
    }

    private fun isTree(col: Int, row: Int, data: Map<Pair<Int, Int>, Char>) = if (data[Pair(col,row)] == '#') 1 else 0
}
